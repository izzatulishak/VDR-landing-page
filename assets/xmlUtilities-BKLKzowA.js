const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/densifyOperator-tzfMlyjQ.js","assets/index-DfdgIpb3.js","assets/index-CIlmxwLw.css","assets/Point2D-DFGf8HqH.js","assets/ProjectionTransformation-DDvAbBdN.js","assets/Envelope2D-B_zpPshd.js","assets/Transformation2D-BUe9nOQ-.js","assets/SimpleGeometryCursor-B92kdZ15.js","assets/OperatorDefinitions-DP7_WWTp.js","assets/jsonConverter-CygPCiiK.js","assets/operatorDensify-BhUdjo-2.js","assets/apiConverter-Ca3dzWlN.js","assets/differenceOperator-DDzuQ6ee.js","assets/lengthOperator-D8BTNye1.js"])))=>i.map(i=>d[i]);
import{aH as Ce,fI as ee,bu as be,ax as ae,s as M,gX as Y,a1 as P,$ as Q,ce as we,i1 as De,aL as _e,fr as ze,_ as I,m as b,bL as ve,b as ue,bq as $e,c as te,P as He,i0 as Me,aK as Je,bw as Ne,ct as Ee}from"./index-DfdgIpb3.js";import{y as Se,C as Oe,s as We,r as Le,a as ke,u as qe,N as fe,p as Ae,l as Ge,d as je,j as Ve,g as Ue,v as de,D as me,h as Qe,b as Xe,U as Ke,c as Ye,e as Ze,f as et,q as tt,W as it,z as nt,B as pe,i as rt,k as ye}from"./RasterJobHandlerMixin-BI1Q32a3.js";import{T as re,R as st,l as at,N as Te,D as ot,a as lt,b as ct,k as ut,O as ht,c as ft}from"./RasterSymbolizer-BlzTeIPS.js";import{t as O,n as dt}from"./datasetUtils-Ce6P7t-y.js";import{QueueProcessor as mt}from"./QueueProcessor-CRuZb6xG.js";import{g as pt}from"./PixelBlock-mCE7QJ_C.js";import{$ as K,j as oe,W as ge,f as xe,c as yt,n as se,H as Z,r as gt,i as xt,C as It,Q as le}from"./rasterProjectionHelper-CGCEkcrd.js";import{r as ce,p as Rt,T as bt}from"./rasterFunctionHelper-CYSTDoSX.js";let wt=class{constructor(t=15e3,n=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=t,this._interval=Math.min(t,n)}decreaseRefCount(t,n){const r=t+"/"+n,e=this._cachedBlocks;if(e.has(r)){const i=e.get(r);return i.refCount--,i.refCount<=0&&(e.delete(r),i.controller&&i.controller.abort()),i.refCount}return 0}getBlock(t,n){const r=t+"/"+n,e=this._cachedBlocks;if(e.has(r)){const i=e.get(r);return i.ts=Date.now(),i.refCount++,e.delete(r),e.set(r,i),i.block}return null}putBlock(t,n,r,e){const i=this._cachedBlocks,a=t+"/"+n;if(i.has(a)){const s=i.get(a);s.ts=Date.now(),s.refCount++}else i.set(a,{block:r,ts:Date.now(),refCount:1,controller:e});this._trim(),this._updateTimer()}deleteBlock(t,n){const r=this._cachedBlocks,e=t+"/"+n;r.has(e)&&r.delete(e)}updateMaxSize(t){this._size=t,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(this._timer!=null)return;const t=this._cachedBlocks;this._timer=setInterval(()=>{const n=Array.from(t),r=Date.now();for(let e=0;e<n.length&&n[e][1].ts<=r-this._duration;e++)t.delete(n[e][0]);t.size===0&&this._clearTimer()},this._interval)}_trim(){const t=this._cachedBlocks;if(this._size===-1||this._size>=t.size)return;const n=Array.from(t);for(let r=0;r<n.length-this._size;r++)t.delete(n[r][0])}_clearTimer(){this._timer!=null&&(clearInterval(this._timer),this._timer=null)}};const ne=new Map,W=new wt;function _t(d,t,n){const r=[];return t!=null&&r.push(`sliceId=${t}`),n!=null&&r.push(`bandIds=${n.join(",")}`),r.length?`${d}?${r.join("&")}`:d}function vt(d,t,n){var a,s;const r=ne.get(d);if(!r)return t==null?W.decreaseRefCount(d,n):0;if(t==null||r[t]==null)return W.decreaseRefCount(d,n);const e=(a=r[t])==null?void 0:a.cache,i=e==null?void 0:e.get(n);if(e&&i){if(i.refCount--,i.refCount===0){e.delete(n);for(let o=0;o<r.length;o++)(s=r[o])==null||s.cache.delete(n);i.controller&&i.controller.abort()}return i.refCount}return 0}function St(d,t,n){var i,a,s;const r=ne.get(d);if(!r)return t==null?W.getBlock(d,n):null;if(t==null||r[t]==null){for(let o=0;o<r.length;o++){const l=(i=r[o])==null?void 0:i.cache.get(n);if(l)return l.refCount++,l.block}return W.getBlock(d,n)}const e=(a=r[t])==null?void 0:a.cache.get(n);if(e)return e.refCount++,e.block;for(let o=0;o<r.length;o++){if(o===t||!r[o])continue;const l=(s=r[o])==null?void 0:s.cache,c=l==null?void 0:l.get(n);if(l&&c)return c.refCount++,l.set(n,c),c.block}return null}function kt(d,t,n,r,e=null){var s;const i=ne.get(d);if(!i)return void(t==null&&W.putBlock(d,n,r,e));if(t==null||i[t]==null)return void W.putBlock(d,n,r,e);const a={refCount:1,block:r,isResolved:!1,isRejected:!1,controller:e};r.then(()=>a.isResolved=!0).catch(()=>a.isRejected=!0),(s=i[t])==null||s.cache.set(n,a)}function Tt(d,t,n){var e;const r=ne.get(d);r?t!=null&&r[t]!=null?(e=r[t])==null||e.cache.delete(n):W.deleteBlock(d,n):t==null&&W.deleteBlock(d,n)}const Ie=8,Bt=256;let Pt=0,v=class extends Ce{constructor(){super(...arguments),this._tileFetchQueue=new mt({concurrency:32,process:(t,n)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:n})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t!=null&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:ee.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,n=K(t.spatialReference);return n!=null&&t.extent.width>=n/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){var n,r;this._set("rasterJobHandler",t),O(this)&&((r=(n=this.primaryRasters)==null?void 0:n.rasters)==null||r.forEach(e=>e.rasterJobHandler=t))}get rasterId(){return this.url||"rasterId-"+Pt++}set url(t){this._set("url",be(t,ae.getLogger(this)))}async open(t){return this._openPromise??(this._openPromise=oe().then(()=>this._open(t))),this._openPromise}async fetchTile(t,n,r,e={}){const i=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,a=this.getTileExtentFromTileInfo(t,n,r,i);if(!a)throw new M("imagery-tile:out-of-bounds","Level for fetch tile out of range");return e={noClip:!0,...e},this.fetchPixels(a,i.size[0],i.size[1],e)}async identify(t,n={}){var J;t=Y(P,t).clone().normalize();const{multidimensionalDefinition:r,timeExtent:e}=n,{rasterInfo:i}=this,{hasMultidimensionalTranspose:a,multidimensionalInfo:s}=i;let{transposedVariableName:o}=n;const l=s!=null&&a&&(e!=null||Se(r));l&&!o&&(o=r!=null&&r.length>0?r[0].variableName??void 0:s.variables[0].name,n={...n,transposedVariableName:o}),n=this._getRequestOptionsWithSliceId(n);const{spatialReference:c,extent:u}=i,{datumTransformation:h}=n;let f=ge(t,c,h);if(!u.intersects(f))return{location:f,value:null};if(i.transform!=null){const z=i.transform.inverseTransform(f);if(!i.nativeExtent.intersects(z))return{location:z,value:null};f=z}let y=0;const g=o!=null&&s!=null&&i.hasMultidimensionalTranspose;if(O(this)){const z=this.primaryRasters.rasters[0];if(g)return z.identify(f,n);const{pixelSize:N}=i,S=3,L=N.x*S/2,q=N.y*S/2,A=new Q({xmin:f.x-L,xmax:f.x+L,ymin:f.y-q,ymax:f.y+q,spatialReference:c}),F={interpolation:"nearest",multidimensionalDefinition:r,sliceId:n.sliceId,bandIds:n.bandIds},{pixelBlock:T}=await z.fetchPixels(A,S,S,F),{pixelBlock:B}=await this.fetchPixels(A,S,S,F);if(T==null)return{location:f,value:null};const C=Math.floor(S*S*.5),G=!T.mask||T.mask[C]?T.pixels.map(D=>D[C]):null;let $;return B!=null&&($=!B.mask||B.mask[C]?B.pixels.map(D=>D[C]):void 0),{location:f,value:G,processedValue:$,pyramidLevel:0}}if(!g){if(n.srcResolution)y=xe(n.srcResolution,i,this.ioConfig.sampling).pyramidLevel;else if(y=await this.computeBestPyramidLevelForLocation(t,n),y==null)return{location:f,value:null}}const x=this.identifyPixelLocation(f,y,null,g);if(x===null)return{location:f,value:null};const{row:p,col:m,rowOffset:R,colOffset:w,blockWidth:_}=x,k=await this._tileFetchQueue.push({pyramidLevel:y,row:p,col:m,options:n},{signal:n.signal});if(!((J=k==null?void 0:k.pixels)!=null&&J.length))return{location:f,value:null};const H=R*_+w;return this._processIdentifyResult(k,{srcLocation:f,position:H,pyramidLevel:y,useTransposedTile:!!g,requestSomeSlices:l,identifyOptions:n})}async fetchPixels(t,n,r,e={}){t=yt(t),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:i}=this;if(e.requestRawData&&i)return this._fetchPixels(t,n,r,e);const a=K(t.spatialReference),s=se(t);if(a==null||s===0||s===1&&this._isGlobalWrappableSource&&i)return this._fetchPixels(t,n,r,e);if(s>=3)return{extent:t,pixelBlock:null};const o=[],{xmin:l,xmax:c}=t,u=Math.round(a/(c-l)*n),h=u-Math.round((a/2-l)/(c-l)*n);let f=0;const y=[];for(let m=0;m<=s;m++){const R=new Q({xmin:m===0?l:-a/2,xmax:m===s?c-a*m:a/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),w=m===0?u-h:m===s?n-f:u;f+=w,y.push(w);const _=e.disableWrapAround&&m>0?null:this._fetchPixels(R,w,r,e);o.push(_)}const g=(await Promise.all(o)).map(m=>m==null?void 0:m.pixelBlock);let x=null;const p={width:n,height:r};return this.rasterJobHandler?x=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:g,srcMosaicSize:p,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:y},e)).pixelBlock:x=re(g,p,{blockWidths:y}),{extent:t,srcExtent:Z(t,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:x}}async fetchRawPixels(t,n,r,e={}){n={x:Math.floor(n.x),y:Math.floor(n.y)};const i=await this._fetchRawTiles(t,n,r,e),{nativeExtent:a,nativePixelSize:s,storageInfo:o}=this.rasterInfo,l=2**t,c=s.x*l,u=s.y*l,h=new Q({xmin:a.xmin+c*n.x,xmax:a.xmin+c*(n.x+r.width-1),ymin:a.ymax-u*(n.y+r.height-1),ymax:a.ymax-u*n.y,spatialReference:a.spatialReference});if(!i)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:f,mosaicSize:y}=i;if(f.length===1&&f[0]!=null&&f[0].width===r.width&&f[0].height===r.height)return{extent:h,srcExtent:h,pixelBlock:i.pixelBlocks[0]};const g=t>0?o.pyramidBlockWidth:o.blockWidth,x=t>0?o.pyramidBlockHeight:o.blockHeight,p={x:n.x%g,y:n.y%x};let m;return this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:f,srcMosaicSize:y,destDimension:r,clipOffset:p,clipSize:r,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:m=re(f,y,{clipOffset:p,clipSize:r}),{extent:h,srcExtent:h,pixelBlock:m}}fetchRawTile(t,n,r,e){throw new M("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Z(this.rasterInfo.extent,t)}decodePixelBlock(t,n){return!this.rasterJobHandler||n.useCanvas?st(t,n):this.rasterJobHandler.decode({data:t,options:n})}async request(t,n,r=0){const{customFetchParameters:e}=this.ioConfig,{range:i,query:a,headers:s}=n;r=r??n.retryCount??this.ioConfig.retryCount;const o=i?{Range:`bytes=${i.from}-${i.to}`}:null;try{return await we(t,{...n,query:{...a,...e},headers:{...s,...o}})}catch(l){if(r>0)return r--,this.request(t,n,r);throw l}}getSliceIndex(t){const{multidimensionalInfo:n}=this.rasterInfo;return n==null||t==null||t.length===0?null:Oe(t,n)}getTileExtentFromTileInfo(t,n,r,e){const i=e.lodAt(t);return i?this.getTileExtent({x:i.resolution,y:i.resolution},n,r,e.origin,e.spatialReference,e.size):null}updateTileInfo(){const{storageInfo:t,spatialReference:n,extent:r,pixelSize:e}=this.rasterInfo,{pyramidResolutions:i}=t;if(!t.tileInfo){const a=[],s=t.maximumPyramidLevel||0;let o=(e.x+e.y)/2,l=1/.0254*96*o;for(let u=0;u<=s&&(a.unshift(new De({level:s-u,resolution:o,scale:l})),u!==s);u++)if(i){const h=(i[u].x+i[u].y)/2;l*=h/o,o=h}else o*=2,l*=2;const c=new P({x:r.xmin,y:r.ymax,spatialReference:n});t.tileInfo=new ee({origin:c,size:[t.blockWidth,t.blockHeight],spatialReference:n,lods:a}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,n=512,r=512,e){const{width:i,height:a,nativeExtent:s,pixelSize:o,spatialReference:l}=t,c=new P({x:s.xmin,y:s.ymax,spatialReference:l});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(i,a))/Math.LN2-8)));const u=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[o],e);t.storageInfo=new at({blockWidth:n,blockHeight:r,pyramidBlockWidth:n,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,n={}){return 0}computeBlockBoundary(t,n,r,e,i,a=0,s=2){if(i.length===1&&a>0){i=[...i];let{x:u,y:h}=i[0];for(let f=0;f<a;f++)u*=s,h*=s,i.push({x:u,y:h})}const o=[],{x:l,y:c}=e;for(let u=0;u<i.length;u++){const{x:h,y:f}=i[u];o.push({minCol:Math.floor((t.xmin-l+.1*h)/n/h),maxCol:Math.floor((t.xmax-l-.1*h)/n/h),minRow:Math.floor((c-t.ymax+.1*f)/r/f),maxRow:Math.floor((c-t.ymin-.1*f)/r/f)})}return o}getPyramidPixelSize(t){const{nativePixelSize:n}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(t===0)return n;if(r!=null&&r.length)return r[t-1];const i=e**t;return{x:n.x*i,y:n.y*i}}identifyPixelLocation(t,n,r,e){const{spatialReference:i,nativeExtent:a,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:o,origin:l,transposeInfo:c}=s,u=e&&c!=null?c.tileSize[0]:s.blockWidth,h=e&&c!=null?c.tileSize[1]:s.blockHeight,f=ge(t,i,r);if(!a.intersects(f)||n<0||n>o)return null;const y=this.getPyramidPixelSize(n),{x:g,y:x}=y,p=(l.y-f.y)/x/h,m=(f.x-l.x)/g/u,R=Math.min(h-1,Math.floor((p-Math.floor(p))*h)),w=Math.min(u-1,Math.floor((m-Math.floor(m))*u));return{pyramidLevel:n,row:Math.floor(p),col:Math.floor(m),rowOffset:R,colOffset:w,blockWidth:u,srcLocation:f}}getTileExtent(t,n,r,e,i,a){const[s,o]=a,l=e.x+r*s*t.x,c=l+s*t.x,u=e.y-n*o*t.y,h=u-o*t.y;return new Q({xmin:l,xmax:c,ymin:h,ymax:u,spatialReference:i})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,n,r){const e=this.rasterInfo.storageInfo.blockBoundary[t];return!e||e.maxRow<n||e.maxCol<r||e.minRow>n||e.minCol>r}updateImageSpaceRasterInfo(t){const{pixelSize:n}=t,{width:r,height:e}=t,i=_e.WebMercator;t.spatialReference=i,t.extent=t.nativeExtent=new Q({xmin:-.5,ymax:.5,xmax:r-.5,ymin:.5-e,spatialReference:i}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new P({x:1,y:1,spatialReference:i});const{extent:a,storageInfo:s}=t;if(s){s.origin=new P({x:a.xmin,y:a.ymax,spatialReference:i});const{pyramidResolutions:o,tileInfo:l}=s;if(o&&o.forEach(c=>{c.x/=n.x,c.y/=n.y}),l){l.origin=s.origin;const c=(t.nativePixelSize.x+t.nativePixelSize.y)/2;l.lods.forEach((u,h)=>{u.resolution=c*2**h,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(t,n,r,e={}){let i=se(t);if(i>=2)return{extent:t,pixelBlock:null};const a=this._getSourceDataInfo(t,n,r,e),{pyramidLevel:s,srcResolution:o,srcExtent:l,srcWidth:c,srcHeight:u,ul:h}=a;if(c===0||u===0)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:f}=this,y=f.transform,g=(y==null?void 0:y.type)==="gcs-shift",x=K(t.spatialReference)!=null;!g&&x||(i=se(a.srcExtent,g));const p=await this._fetchRawTiles(s,h,{width:c,height:u,wrapCount:i},e);if(!p)return{extent:t,srcExtent:l,pixelBlock:null};const m=f.storageInfo,R=s>0?m.pyramidBlockWidth:m.blockWidth,w=s>0?m.pyramidBlockHeight:m.blockHeight;let{x:_,y:k}=f.pixelSize;if(s>0){const{pyramidResolutions:E,pyramidScalingFactor:Fe}=m;if(E!=null&&E[s-1])({x:_,y:k}=E[s-1]);else{const he=Fe**s;_*=he,k*=he}}const H=f.spatialReference,J=new P({x:_,y:k,spatialReference:H}),z=R===c&&w===u&&h.x%R===0&&h.y%w===0,N=new P({x:(t.xmax-t.xmin)/n,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference}),S=!t.spatialReference.equals(H),L=H.isGeographic?1e-9:1e-4,{datumTransformation:q}=e;if(!S&&z&&p.pixelBlocks.length===1&&R===n&&w===r&&Ft(o,N,L))return{extent:t,srcExtent:l,srcTilePixelSize:J,pixelBlock:p.pixelBlocks[0]};const A=x&&K(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,F=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");F&&!this.rasterJobHandler&&await oe();const T=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:p.extent,pixelSize:N.toJSON(),datumTransformation:q,rasterTransform:y,hasWrapAround:i>0||A,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:F},e):gt({projectedExtent:t,srcBufferExtent:p.extent,pixelSize:N,datumTransformation:q,rasterTransform:y,hasWrapAround:i>0||A,isAdaptive:!1,includeGCSGrid:F});let B;const C=!e.requestRawData,G={rows:T.spacing[0],cols:T.spacing[1]},$=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,p.extent.xmin):void 0,{pixelBlocks:D,mosaicSize:j,isPartiallyFilled:X}=p;let V=null;if(this.rasterJobHandler)({pixelBlock:B,localNorthDirections:V}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:D,srcMosaicSize:j,destDimension:C?{width:n,height:r}:null,coefs:C?T.coefficients:null,sampleSpacing:C?G:null,projectDirections:F,gcsGrid:F?T.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:$,blockWidths:null},e));else{const E=re(D,j,{alignmentInfo:$});B=C?Te(E,{width:n,height:r},T.coefficients,G,e.interpolation):E,F&&T.gcsGrid&&(V=ot({width:n,height:r},T.gcsGrid),B=lt(B,this.rasterInfo.dataType,V))}return e.requestRawData||F?{extent:t,srcExtent:l,srcTilePixelSize:J,pixelBlock:B,transformGrid:T,localNorthDirections:V,isPartiallyFilled:X}:{extent:t,srcExtent:l,srcTilePixelSize:J,pixelBlock:B}}async _fetchRawTiles(t,n,r,e){const{origin:i,blockBoundary:a}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:o}=this.getBlockWidthHeight(t);let{x:l,y:c}=n,{width:u,height:h,wrapCount:f}=r;const y=this._getRasterTileAlignmentInfo(t,0);e.buffer&&(l-=e.buffer.cols,c-=e.buffer.rows,u+=2*e.buffer.cols,h+=2*e.buffer.rows);let g=0,x=0,p=0;f&&y!=null&&({worldColumnCountFromOrigin:x,originColumnOffset:p,rightPadding:g}=y,x*y.blockWidth-g>=l+u&&(g=0));const m=Math.floor(l/s),R=Math.floor(c/o),w=Math.floor((l+u+g-1)/s),_=Math.floor((c+h+g-1)/o),k=a[t];if(!k)return null;const{minRow:H,minCol:J,maxCol:z,maxRow:N}=k;if(f===0&&(_<H||w<J||R>N||m>z))return null;const S=new Array;let L=!1;const q=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let $=R;$<=_;$++)for(let D=m;D<=w;D++){let j=D;if(!e.disableWrapAround&&f&&y!=null&&x<=D&&(j=D-x-p),$>=H&&j>=J&&N>=$&&z>=j){const X=this._tileFetchQueue.push({pyramidLevel:t,row:$,col:j,options:e},{signal:e.signal});q?S.push(new Promise(V=>{X.then(E=>V(E)).catch(()=>{L=!0,V(null)})})):S.push(X)}else S.push(Promise.resolve(null))}if(S.length===0)return null;const A=await Promise.all(S),F={height:(_-R+1)*o,width:(w-m+1)*s},{spatialReference:T}=this.rasterInfo,B=this.getPyramidPixelSize(t),{x:C,y:G}=B;return{extent:new Q({xmin:i.x+m*s*C,xmax:i.x+(w+1)*s*C,ymin:i.y-(_+1)*o*G,ymax:i.y-R*o*G,spatialReference:T}),pixelBlocks:A,mosaicSize:F,isPartiallyFilled:L}}_fetchRawTile(t,n,r,e){const{storageInfo:i}=this.rasterInfo,a=i.transposeInfo!=null&&!!e.transposedVariableName;if(!a){const h=i.blockBoundary[t];if(!h)return Promise.resolve(null);const{minRow:f,minCol:y,maxCol:g,maxRow:x}=h;if(n<f||r<y||n>x||r>g)return Promise.resolve(null)}const s=a?e.transposeVariableName:e.sliceId,o=this.rasterInfo.storageInfo.isBsqTile?e.bandIds:null,l=_t(this.rasterId,s,o),c=`${t}/${n}/${r}`;let u=St(l,e.registryId,c);if(u==null){const h=new AbortController;u=this.fetchRawTile(t,n,r,{...e,signal:h.signal}),kt(l,e.registryId,c,u,h),u.catch(()=>Tt(l,e.registryId,c))}return e.signal&&ze(e,()=>{vt(l,e.registryId,c)}),u}_computeMagDirValues(t){var l;const{bandCount:n,dataType:r}=this.rasterInfo;if(!(n===2&&r==="vector-magdir"||r==="vector-uv")||(t==null?void 0:t.length)!==2||!((l=t[0])!=null&&l.length))return null;const e=t[0].length;if(r==="vector-magdir"){const c=t[1].map(u=>(u+360)%360);return[t[0],c]}const[i,a]=t,s=[],o=[];for(let c=0;c<e;c++){const[u,h]=ct([i[c],a[c]]);s.push(u),o.push(h)}return[s,o]}_getRasterTileAlignmentInfo(t,n){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=xt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:n,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,n,r,e={}){const i={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(i.srcResolution=e.srcResolution,this._updateSourceDataInfo(t,i));const a=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:o,pyramidLevel:l}=i,c=s/n,u=o/r,h=l<a&&c*u>=16,f=l===a&&this._requireTooManySrcTiles(s,o,n,r);if(h||f||s===0||o===0){const y=new P({x:(t.xmax-t.xmin)/n,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference});let g=It(y,this.rasterInfo.spatialReference,t,i.datumTransformation);const x=!g||e.srcResolution&&g.x+g.y<e.srcResolution.x+e.srcResolution.y;if(h&&e.srcResolution&&x){const p=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(a-l+3>=p){const m=2**p;g={x:e.srcResolution.x*m,y:e.srcResolution.y*m}}}g&&(i.srcResolution=g,this._updateSourceDataInfo(t,i))}return this._requireTooManySrcTiles(i.srcWidth,i.srcHeight,n,r)&&(i.srcWidth=0,i.srcHeight=0),i}_requireTooManySrcTiles(t,n,r,e){const{tileInfo:i}=this.rasterInfo.storageInfo,a=Math.ceil(t/i.size[0])*Math.ceil(n/i.size[1]),s=t/r,o=n/e,l=Math.max(1,(r+e)/1024);return a>=Bt*l||s>Ie||o>Ie}_updateSourceDataInfo(t,n){n.srcWidth=0,n.srcHeight=0;const{rasterInfo:r}=this,e=r.spatialReference,{srcResolution:i,datumTransformation:a}=n,{pyramidLevel:s,pyramidResolution:o,excessiveReading:l}=xe(i,r,this.ioConfig.sampling);if(l)return;let c=n.srcExtent||Z(t,e,a);if(c==null)return;const u=r.transform;u&&(c=u.inverseTransform(c)),n.srcExtent=c;const{origin:h}=r.storageInfo,{width:f,height:y,ul:g}=dt(c,h,o,s);n.pyramidLevel=s,n.pyramidResolution=o,n.srcWidth=f,n.srcHeight=y,n.ul=g}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,n){const{srcLocation:r,position:e,pyramidLevel:i,useTransposedTile:a}=n,s=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[e]))return{location:r,value:null};const{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!a){const p=t.pixels.map(w=>w[e]),m={location:r,value:p,pyramidLevel:i},R=this._computeMagDirValues(p.map(w=>[w]));return R!=null&&R.length&&(m.magdirValue=R.map(w=>w[0])),m}let l=t.pixels.map(p=>p.slice(e*s,e*s+s)),c=this._computeMagDirValues(l);const{requestSomeSlices:u,identifyOptions:h}=n;let f=We(o,h.transposedVariableName);if(u){const p=Le(f,h.multidimensionalDefinition,h.timeExtent);l=l.map(m=>p.map(R=>m[R])),c=c==null?void 0:c.map(m=>p.map(R=>m[R])),f=p.map(m=>f[m])}const y=t.noDataValues||this.rasterInfo.noDataValue,g={pixels:l,pixelType:t.pixelType};let x;return y!=null&&(pt(g,y),x=g.mask),{location:r,value:null,dataSeries:f.map((p,m)=>{const R={value:(x==null?void 0:x[m])===0?null:l.map(w=>w[m]),multidimensionalDefinition:p.multidimensionalDefinition.map(w=>new ke({...w,isSlice:!0}))};return c!=null&&c.length&&(R.magdirValue=[c[0][m],c[1][m]]),R}),pyramidLevel:i}}};function Ft(d,t,n){return Math.abs(d.x-t.x)<n&&Math.abs(d.y-t.y)<n}I([b()],v.prototype,"_rasterTileAlignmentInfo",void 0),I([b()],v.prototype,"_tileFetchQueue",void 0),I([b({readOnly:!0})],v.prototype,"_isGlobalWrappableSource",null),I([b({readOnly:!0})],v.prototype,"_hasNoneOrGCSShiftTransform",null),I([b()],v.prototype,"_openPromise",void 0),I([b()],v.prototype,"rasterJobHandler",null),I([b({readOnly:!0})],v.prototype,"rasterId",null),I([b(ve)],v.prototype,"url",null),I([b({type:String,json:{write:!0}})],v.prototype,"datasetName",void 0),I([b({type:String,json:{write:!0}})],v.prototype,"datasetFormat",void 0),I([b()],v.prototype,"hasUniqueSourceStorageInfo",void 0),I([b()],v.prototype,"rasterInfo",void 0),I([b()],v.prototype,"ioConfig",void 0),I([b()],v.prototype,"sourceJSON",void 0),v=I([ue("esri.layers.support.rasterDatasets.BaseRaster")],v);const Ct=40;let U=class extends v{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(d,t,n,r={}){var R,w;const{rasters:e,rasterIds:i}=this.primaryRasters;let a=!1;const{interpolation:s}=r,o=(R=this.rasterFunction.flatWebGLFunctionChain)==null?void 0:R.hasFocalFunction;!r.requestRawData&&o&&(a=e.length===1&&!r.skipRasterFunction,r={...r,interpolation:"bilinear",requestRawData:a}),r.requestRawData&&e.length>1&&!this.hasUniqueSourceStorageInfo&&(a=!1,r={...r,requestRawData:!1});const l=e.map(_=>_.fetchPixels(d,t,n,r)),c=await Promise.all(l),u=c.map(_=>_.pixelBlock),h=a||r.requestRawData?c.map(_=>_.srcTilePixelSize):null;if(r.skipRasterFunction||u.every(_=>_==null))return c[0];const f=((w=c.find(_=>_.pixelBlock!=null))==null?void 0:w.extent)??d;let y=this.rasterJobHandler?await this.rasterJobHandler.process({extent:f,primaryPixelBlocks:u,primaryPixelSizes:h,primaryRasterIds:i}):this.rasterFunction.process({extent:f,primaryPixelBlocks:u,primaryPixelSizes:h,primaryRasterIds:i});const{transformGrid:g}=c[0];if(!a||y==null||g==null){const _=r.noClip?null:this.getClippingGeometry(f.spatialReference);return!r.noClip&&y!=null&&_&&(y=await ce(y,f,_)),{...c[0],pixelBlock:y}}const x={rows:g.spacing[0],cols:g.spacing[1]};let p;this.rasterJobHandler?p=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[y],srcMosaicSize:{width:y.width,height:y.height},destDimension:{width:t,height:n},coefs:g.coefficients,sampleSpacing:x,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:s,alignmentInfo:void 0,blockWidths:null},r)).pixelBlock:p=Te(y,{width:t,height:n},g.coefficients,x,s);const m=r.noClip?null:this.getClippingGeometry(d.spatialReference);return r.noClip||p==null||m==null||(p=await ce(p,d,m)),{extent:d,srcExtent:c[0].srcExtent,pixelBlock:p}}getClippingGeometry(d){const t=this._clippingGeometry.get("0");if(!d||!t)return t;const n=zt(d);let r=this._clippingGeometry.get(n);return r!=null||(r=d.equals(t.spatialReference)?t:le(t,d),this._clippingGeometry.set(n,r)),r}async _open(d){var l,c,u,h;const{rasterFunction:t}=this;t.isRoot=!0,(c=(l=this.primaryRasters)==null?void 0:l.rasters)!=null&&c.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&((u=this.primaryRasters.rasters)==null||u.forEach(f=>f.rasterJobHandler=this.rasterJobHandler)));const{rasters:n,rasterIds:r}=this.primaryRasters,e=n.map(f=>f.rasterInfo?void 0:f.open(d));await Promise.all(e);const i=n.map(({rasterInfo:f})=>f),a=t.bind({rasterInfos:i,rasterIds:r});if(t.rawSourceRasterInfos=i,!a.success||i.length===0)throw new M("raster-function:open",`cannot bind the function: ${a.error??""}`);const s=t.functionName==="Table"?t:(h=t.functionArguments)==null?void 0:h.raster;(s==null?void 0:s.functionName)==="Table"&&(t.rasterInfo.attributeTable=$e.fromJSON(s.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const o=i[0];this.hasUniqueSourceStorageInfo=i.length===1||i.slice(1).every(f=>Dt(f,o)),this.set("sourceJSON",n[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var d;return(d=this.rasterJobHandler)==null?void 0:d.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const d=this.rasterFunction.getClippingGeometries()[0];let t=d==null?void 0:d.clippingGeometry;if(t&&d.clippingType==="inside"){const{extent:n}=this.rasterInfo,r=await te(()=>import("./densifyOperator-tzfMlyjQ.js").then(a=>a.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])),e=await te(()=>import("./differenceOperator-DDzuQ6ee.js").then(a=>a.d),__vite__mapDeps([12,3,4,5,6,7,1,2,8,9,11]));let i=r.execute(He.fromExtent(n),2*(n.width+n.height)/Ct);i=le(i,t.spatialReference),t=e.execute(i,t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set("0",t)}};function Dt(d,t){const{storageInfo:n,pixelSize:r,spatialReference:e,extent:i}=d,{storageInfo:a,pixelSize:s,spatialReference:o,extent:l}=t;return r.x===s.x&&r.y===s.y&&e.equals(o)&&i.equals(l)&&n.blockHeight===a.blockHeight&&n.blockWidth===a.blockWidth&&n.maximumPyramidLevel===a.maximumPyramidLevel&&n.firstPyramidLevel===a.firstPyramidLevel&&n.pyramidBlockWidth===a.pyramidBlockWidth&&n.pyramidBlockHeight===a.pyramidBlockHeight&&n.pyramidScalingFactor===a.pyramidScalingFactor}function zt(d){return String(d.wkid??d.wkt??d.wkt2)}I([b({type:String,json:{write:!0}})],U.prototype,"datasetFormat",void 0),I([b()],U.prototype,"tileType",void 0),I([b()],U.prototype,"rasterFunction",void 0),I([b()],U.prototype,"primaryRasters",void 0),U=I([ue("esri.layers.support.rasterDatasets.FunctionRaster")],U);const Re=1e3,Gt=d=>{const t=d;let n=class extends t{constructor(...e){var i;super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=O((i=e[0])==null?void 0:i.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){var e;return(e=this.serviceRasterInfo)==null?void 0:e.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){var i;((i=e==null?void 0:e.functionName)==null?void 0:i.toLowerCase())==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",be(e,ae.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:i}=this;if(e){const a=i==null?void 0:i.find(({name:s})=>s===e);return a==null?void 0:a.renderer.clone()}return this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,i,a){var o,l;const s=(l=(o=i==null?void 0:i.layerDefinition)==null?void 0:o.drawingInfo)==null?void 0:l.renderer;return je(s,a)||void 0}async computeStatisticsHistograms(e,i){await this.load(i),e=Y(Ve,e).clone();const{serviceRasterInfo:a}=this;if(a==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:s}=e;if(s==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let o=s;const{spatialReference:l}=a;if(!s.spatialReference.equals(l)){await oe();const p=s.type==="extent"?Z(s,l):le(s,l);if(p==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");o=p}const c=e.pixelSize??new P({x:a.pixelSize.x,y:a.pixelSize.y,spatialReference:l}),{extent:u,width:h,height:f}=Rt(a,o,c),y=await this.fetchPixels(u,h,f,{...i,interpolation:"nearest"});if(y.pixelBlock==null)throw new M("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const g=await ce(y.pixelBlock,u,o),x=this._rasterJobHandler;return x?x.computeStatisticsHistograms({pixelBlock:g},i):ut(g)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:i}=this.serviceRasterInfo??{};if(i==null)return e;const a=Ue({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:a,timeExtent:void 0}}async updateRasterFunction(){var e;return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=(e=this.rasterFunction)==null?void 0:e.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:i,renderer:a}=this;if(!e||!i||!a)return;const{rasterInfo:s}=this.raster,o=de(s,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),l=o==null?void 0:o.name,c=me(s,l);return this._updateSymbolizer(i,a,l,c)}async applyRenderer(e,i,a){const s=e==null?void 0:e.pixelBlock;if(!(s!=null&&s.pixels&&s.pixels.length>0))return null;await this.updateRenderer();const o=this.bandIds??[],{pixelBlock:l}=await this._symbolize({pixelData:e,simpleStretchParams:i,bandIds:o,symbolizer:this.symbolizer},a);return l}getRawDisplayBandIds(){let{bandIds:e,raster:i}=this;if(this.rasterFunction&&O(i)){const a=i.rasterFunction.rawInputBandIds;e=e!=null&&e.length&&(a!=null&&a.length)&&i.rasterInfo.bandCount!==1?e.map(s=>a[Math.min(s,a.length-1)]):a}return e&&e.length>3&&e.every((a,s)=>a===s)?null:e}getTileUrl(e,i,a){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${i}/${a}`:""}getCompatibleTileInfo(e,i,a=!1){if(!this.loaded||i==null)return null;if(a&&e.equals(this.spatialReference))return this.tileInfo;const s=Ee(e);return ee.create({size:256,spatialReference:e,origin:s?{x:s.origin[0],y:s.origin[1]}:{x:i.xmin,y:i.ymax}})}getCompatibleFullExtent(e){var i;return this.loaded?((i=this._compatibleFullExtent)!=null&&i.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,i,a,s={}){var l;if(r(this),s.requestAsImageElement){const c=this.getTileUrl(e,i,a);return we(c,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:s.signal}).then(u=>u.data)}const{serviceRasterInfo:o}=this;if(o.multidimensionalInfo!=null&&(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition==null){const c=s.tileInfo||o.storageInfo.tileInfo,u=this.raster.getTileExtentFromTileInfo(e,i,a,c);if(u)return{extent:u,pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),((l=this.renderer)==null?void 0:l.type)==="raster-shaded-relief"&&(s={...s,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,i,a,s)}async fetchPixels(e,i,a,s={}){var l,c;if(this.serviceRasterInfo.multidimensionalInfo!=null&&(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition==null)return{extent:e,pixelBlock:null};await this._initJobHandler(),await this.updateRasterFunction(),i=Math.round(i),a=Math.round(a);const o=await this.raster.fetchPixels(e,i,a,s);return(l=s.bandIds)!=null&&l.length&&!this.raster.rasterInfo.storageInfo.isBsqTile&&(o.pixelBlock=(c=o.pixelBlock)==null?void 0:c.extractBands(s.bandIds)),o}async getSamples(e,i){var c;if(await this.load(),(e=Y(Qe,e).clone()).interpolation&&e.interpolation!=="nearest")throw new M("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const a=(c=e.mosaicRule)==null?void 0:c.multidimensionalDefinition,s={...i,multidimensionalDefinition:a},o=(await this._getSampleLocations(e)).map(u=>this.identify(u,s).then(h=>(h.location=u,h))),l=(await Promise.all(o)).flatMap((u,h)=>this._convertRasterIdentifyResultToSample(u,h));return new Xe({samples:l})}async identify(e,i={}){var c,u;await this.load(),e=Y(P,e).clone().normalize();const{raster:a,serviceRasterInfo:s}=this;if((s==null?void 0:s.multidimensionalInfo)!=null&&!(s.hasMultidimensionalTranspose&&!(!Se(i.multidimensionalDefinition)&&!i.transposedVariableName))&&(i=this.normalizeRasterFetchOptions(i)).multidimensionalDefinition==null)return{location:e,value:null};const o=(c=this.multidimensionalSubset)==null?void 0:c.areaOfInterest;if(o&&!o.contains(e))throw new M("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");let l;if((u=this.serviceRasterInfo)!=null&&u.storageInfo.isBsqTile){const h=O(a)?this.getRawDisplayBandIds():this.bandIds;l=h!=null&&h.length?h:void 0}return a.identify(e,{...i,bandIds:l})}hasStandardTime(){var s,o,l;const e=(s=this.serviceRasterInfo)==null?void 0:s.multidimensionalInfo;if(e==null||((o=this.serviceRasterInfo)==null?void 0:o.dataType)!=="standard-time")return!1;const i=this.multidimensionalDefinition,a=(l=i==null?void 0:i[0])==null?void 0:l.variableName;return e.variables.some(c=>c.name===a&&(!(i!=null&&i[0].dimensionName)||c.dimensions.some(u=>u.name==="StdTime")))}getStandardTimeValue(e){return new Date(Ke(e)).toISOString()}getMultidimensionalSubsetVariables(e){var a;const i=e??((a=this.serviceRasterInfo)==null?void 0:a.multidimensionalInfo);return Ye(this.multidimensionalSubset,i)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Ze(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&O(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;r(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,O(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:i}=e;if(i.type==="point")return[i];const{spatialReference:a,type:s}=i;if(s==="multipoint")return i.points.map(p=>new P({x:p[0],y:p[1],spatialReference:a}));if(s==="polyline"){let p=i;if(e.sampleCount||e.sampleDistance){const m=await te(()=>import("./densifyOperator-tzfMlyjQ.js").then(k=>k.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11])),R=(await te(async()=>{const{execute:k}=await import("./lengthOperator-D8BTNye1.js").then(H=>H.l);return{execute:k}},__vite__mapDeps([13,1,2,3,5,4,6,7,8,9,11]))).execute(i,{unit:"meters"}),w=Math.min(e.sampleCount||100,Re);let _=e.sampleDistance;_||(_=R/(w+(p.paths[0].length===2?1:0))),p=m.execute(i,_,{unit:"meters"})}return p.paths.flatMap(m=>m.map(R=>new P({x:R[0],y:R[1],spatialReference:a})))}const o=Math.min(e.sampleCount||100,Re),l=i.type==="extent",c=l?i:i.extent,u=Math.sqrt(c.width*c.height/o),h=c.height/u,f=c.width/u,{xmin:y,ymax:g}=c,x=[];for(let p=0;p<h;p++)for(let m=0;m<f;m++){const R=new P({x:y+(m+.5)*u,y:g-(p+.5)*u,spatialReference:a});(l||i.contains(R))&&x.push(R)}return x}_configDefaultInterpolation(){var e;if(this.interpolation==null){r(this);const{raster:i}=this,a=et(i.rasterInfo,i.tileType,(e=this.sourceJSON)==null?void 0:e.defaultResamplingMethod);this._set("interpolation",a)}}_configDefaultRenderer(e="no"){var h,f,y;r(this);const{rasterInfo:i}=this.raster,a=de(i,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),s=a==null?void 0:a.name,o=tt({variableName:s,rasterFunctionName:(h=this.rasterFunction)==null?void 0:h.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&i.bandCount>1&&(this.bandIds=(o==null?void 0:o.bandIds)??it(i)),!this.renderer||e==="override"){const g=nt(this.raster),x=(o==null?void 0:o.renderer)??pe(i,{bandIds:this.bandIds,variableName:s,rasterFunctionColorRamp:g}),p=i.statistics,m=p&&p.length>0?p[0]:null,R=(m==null?void 0:m.max)??0,w=(m==null?void 0:m.min)??0;this.raster.datasetFormat==="WCSServer"&&x.type==="raster-stretch"&&(R>1e24||w<-1e24)&&(x.dynamicRangeAdjustment=!0,x.customStatistics=null,x.stretchType==="none"&&(x.stretchType="min-max")),this.renderer=x}const l=rt({...this.renderer.toJSON(),variableName:s}),c=me(i,s);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=c):this.symbolizer=new ht({rendererJSON:l,rasterInfo:c});const u=this.symbolizer.bind();if(u.success){if(e==="auto"){const{colormap:g}=this.raster.rasterInfo,x=this.renderer;if(g!=null&&x.type==="raster-colormap"){const p=pe(this.raster.rasterInfo);JSON.stringify(p)!==JSON.stringify(x)&&this._configDefaultRenderer("override")}else if(x.type==="raster-stretch"){const p=(f=this.bandIds)==null?void 0:f.length,m=(y=x.customStatistics)==null?void 0:y.length;!x.dynamicRangeAdjustment&&m&&p&&m!==p&&this._configDefaultRenderer("override")}}}else ae.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){var u;if(this._isConstructedFromFunctionRaster&&O(this.raster)){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",fe.fromJSON(h)))}let e,i=this.raster,a=!1;O(i)?(e=i.primaryRasters.rasters,i=e[0],a=!0):e=[i];const{rasterFunction:s}=this;if(s){const h={raster:i};e.length>1&&e.forEach(g=>h[g.url]=g);const f=bt(((u=s.functionDefinition)==null?void 0:u.toJSON())??s.toJSON(),h),y=new U({rasterFunction:f});y.rasterJobHandler=this._rasterJobHandler,await y.open(),this.raster=y}else this.raster=i,await i.open();if(this._cachedRendererJson=void 0,!a&&!s)return;const{bandIds:o}=this,{bandCount:l}=this.raster.rasterInfo,c=o!=null&&o.length?o.some(h=>h>=l):l>=3;o&&(c||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,i){var c;const{rasterInfo:a}=this.raster,s=a.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),o=(a.pixelSize.x+a.pixelSize.y)/2*s;if(!((c=e.dataSeries)!=null&&c.length))return[new ye({location:e.location,pixelValue:e.value,locationId:i,resolution:o})];const l=[];return e.dataSeries.forEach(({value:u,multidimensionalDefinition:h},f)=>{const y={Variables:h[0].variableName,Dimensions:h.flatMap(({dimensionName:x})=>x).join(",")};for(const{dimensionName:x,values:p}of h){y[x]=Array.isArray(p[0])?p[0][0]:p[0];const m=p[p.length-1];y[`${x}_Max`]=Array.isArray(m)?m[m.length-1]:m}const g=new ye({location:e.location,pixelValue:u,rasterId:f,locationId:i,resolution:o,attributes:y});l.push(g)}),l}};function r(e){if(!e.raster||!e.serviceRasterInfo)throw new M("imagery-tile","no raster")}return I([b({clonable:!1})],n.prototype,"_cachedRasterFunctionJson",void 0),I([b({clonable:!1})],n.prototype,"_compatibleFullExtent",void 0),I([b({clonable:!1})],n.prototype,"_isConstructedFromFunctionRaster",void 0),I([b({clonable:!1})],n.prototype,"_rasterFunctionUpdatePromise",void 0),I([b({type:[Me],json:{write:{overridePolicy(){var e;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((e=this.bandIds)==null?void 0:e.join(","))!=="0,1,2"}}}}})],n.prototype,"bandIds",void 0),I([b({json:{origins:{service:{read:{source:"copyrightText"}}}}})],n.prototype,"copyright",void 0),I([b({json:{read:!1}})],n.prototype,"fullExtent",null),I([b({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Je(ft)],n.prototype,"interpolation",void 0),I([b()],n.prototype,"ioConfig",void 0),I([b({type:[ke],json:{write:!0}})],n.prototype,"multidimensionalDefinition",null),I([b({type:qe,json:{write:!0}})],n.prototype,"multidimensionalSubset",void 0),I([b()],n.prototype,"raster",void 0),I([b({type:fe})],n.prototype,"rasterFunction",null),I([b()],n.prototype,"serviceRasterInfo",void 0),I([b()],n.prototype,"sourceJSON",void 0),I([b({readOnly:!0,type:_e,json:{read:!1}})],n.prototype,"spatialReference",void 0),I([b({type:ee})],n.prototype,"tileInfo",void 0),I([b(ve)],n.prototype,"url",null),I([b()],n.prototype,"renderer",null),I([b({types:Ge,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var i;const e=((i=this.renderer)==null?void 0:i.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Ae,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"})}}}}})],n.prototype,"internalRenderer",null),I([Ne("internalRenderer")],n.prototype,"readRenderer",null),I([b({clonable:!1})],n.prototype,"symbolizer",void 0),n=I([ue("esri.layers.mixins.ImageryTileMixin")],n),n};function ie(d,t){if(!d||!t)return[];let n=t;t.includes("/")?(n=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const r=[];if(t){const i=ie(d,n);for(let a=0;a<i.length;a++)ie(i[a],t).forEach(s=>r.push(s));return r}const e=d.getElementsByTagNameNS("*",n);if(!e||e.length===0)return[];for(let i=0;i<e.length;i++)r.push(e[i]||e.item(i));return r}function Be(d,t){if(!d||!t)return null;let n=t;t.includes("/")?(n=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const r=ie(d,n);return r.length>0?t?Be(r[0],t):r[0]:null}function Pe(d,t=null){const n=t?Be(d,t):d;let r;return n?(r=n.textContent||n.nodeValue,r?r.trim():null):null}function $t(d,t){const n=ie(d,t),r=[];let e;for(let i=0;i<n.length;i++)e=n[i].textContent||n[i].nodeValue,e&&(e=e.trim(),e!==""&&r.push(e));return r}function jt(d,t=null){const n=Pe(d,t);return(n==null?void 0:n.split(" ").map(r=>Number(r)))??[]}function Vt(d,t){return $t(d,t).map(n=>Number(n))}function Ut(d,t){const n=Pe(d,t);return Number(n)}function Qt(d,t){var e;const n=(e=d==null?void 0:d.nodeName)==null?void 0:e.toLowerCase(),r=t.toLowerCase();return n.slice(n.lastIndexOf(":")+1)===r}function Xt(d){return d.nodeName.slice(d.nodeName.lastIndexOf(":")+1)}export{v as X,Gt as a,Xt as c,Be as e,Qt as i,$t as l,U as m,ie as n,Ut as o,jt as r,Pe as t,Vt as u};
