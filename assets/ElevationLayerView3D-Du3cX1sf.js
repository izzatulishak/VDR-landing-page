const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/containsOperator-Jw-L9aDW.js","assets/ProjectionTransformation-D8xEIsSe.js","assets/Envelope2D-B_zpPshd.js","assets/Point2D-DFGf8HqH.js","assets/Transformation2D-BUe9nOQ-.js","assets/SimpleGeometryCursor-B92kdZ15.js","assets/index-BiSWWdHA.js","assets/index-CUvnBExu.css","assets/OperatorDefinitions-DP7_WWTp.js","assets/jsonConverter-DrlLbkf4.js","assets/apiConverter-B9n_pEjl.js","assets/intersectsOperator-BprMKphb.js","assets/OperatorIntersects-BDnHv7op.js","assets/intersectionOperator-BowvHTG7.js","assets/operatorIntersection-CtZSVGdE.js","assets/simplifyOperator-Dsd2bGZf.js","assets/operatorSimplify-96A5wgi1.js"])))=>i.map(i=>d[i]);
import{c as P,bY as I,fd as C,$ as G,s as M,fG as S,bX as U,ir as b,ax as R,_ as x,m as L,b as j}from"./index-BiSWWdHA.js";import{s as z,a as F}from"./LercDecoder-KDNnNoBu.js";import{l as k}from"./LayerView3D-D7-E2zMU.js";import{p as X}from"./TiledLayerView3D-C5qNnRVh.js";import{d as Y}from"./LayerView-XxBSWkwC.js";class Z{constructor(){this.modifications=[]}async apply(o,t,e){if(this.modifications.length!==0&&(V??(V=Promise.all([P(()=>import("./containsOperator-Jw-L9aDW.js").then(i=>i.c),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10])),P(()=>import("./intersectsOperator-BprMKphb.js").then(i=>i.i),__vite__mapDeps([11,1,2,3,4,5,6,7,8,9,12,10])),P(()=>import("./intersectionOperator-BowvHTG7.js").then(i=>i.i),__vite__mapDeps([13,6,7,3,1,2,4,5,8,9,14,10]))])),O=await V,!I(e)))for(const i of this.modifications)i.apply(o,t)}}class B{constructor(o,t){this.type=o,this.polygon=t}apply(o,t){if(this.type!=="replace")return;const{polygon:e}=this,[i,a,l]=O,{extent:h,spatialReference:y}=t,_=C(h,y);if(a.accelerateGeometry(e),!a.execute(e,_))return;i.accelerateGeometry(e),l.accelerateGeometry(e);const{width:n,height:d,values:m}=o,g=e.hasZ?e.rings.reduce((r,p)=>p.reduce((c,u)=>Math.min(c,u[2]??1/0),r),1/0):1/0,f=g===1/0?0:g;if(i.execute(e,_))m.fill(f);else{const r=H(t,e,[n,d]);if(!r||r.rings.every(c=>c.length===0))return;const p=J(t,r,n,d);for(let c=d-1;c>=0;--c)for(let u=0;u<n;++u){const T=(c+1)*(n+2)+(u+1);let w=0;for(let $=-1;$<=1;++$){const q=T+$*(n+2);for(let E=-1;E<=1;++E)w=Math.max(w,p[q+E])}const D=c*n+u;m[D]=w===0?m[D]:f}}}}let V,O;function H(s,o,t){const[e,i,a,l]=s.extent,{spatialReference:h}=s,[y,_]=t,n=2,d=(a-e)/(y-1),m=(l-i)/(_-1),g=new G({xmin:e-n*d,ymin:i-n*m,xmax:a+n*d,ymax:l+n*m,spatialReference:h}),f=O[2].execute(o,g);return(f==null?void 0:f.type)==="polygon"?f:null}function J(s,o,t,e){const i=new OffscreenCanvas(t+2,e+2).getContext("2d",{willReadFrequently:!0});if(!i)throw new Error("failed to create canvas");const[a,l,h,y]=s.extent,_=h-a,n=y-l;i.fillStyle="black",i.clearRect(0,0,t,e);const d=new Path2D;for(const r of o.rings)if(r.length>0){const p=new Path2D;let c=!0;for(const[u,T]of r){const w=(u-a)/_*(t-1)+1+A,D=(y-T)/n*(e-1)+1+A;c?(c=!1,p.moveTo(w,D)):p.lineTo(w,D)}p.closePath(),d.addPath(p)}i.fillStyle="white",i.fill(d,"evenodd");const m=i.getImageData(0,0,t+2,e+2),g=(t+2)*(e+2),f=new Uint8Array(g);for(let r=0;r<g;++r)f[r]=m.data[4*r+0]>0?1:0;return f}const A=.5;let v=class extends X(k(Y)){constructor(){super(...arguments),this.type="elevation-3d",this.modifications=new Z}get tileInfo(){return this.layer.tileInfo}initialize(){var a,l,h;const s=this.view,o=(a=s.map)==null?void 0:a.allLayers,t=o&&o.includes(this.layer),e=(h=(l=s.map)==null?void 0:l.ground)==null?void 0:h.layers,i=e&&e.includes(this.layer);if(t&&!i){const y=new M("layerview:elevation-layer-only",`3D elevation layer '${this.layer.id}' can only be added to layers in map.ground`);this.addResolvingPromise(Promise.reject(y))}this._lercDecoder=z(s.resourceController),this._addTilingSchemeMatchPromise()}destroy(){this._lercDecoder=S(this._lercDecoder)}async fetchElevationTile(s,o){const t=await this._fetchTileData(s.lij,o);if(!I(o))return t&&await this.modifications.apply(t,s,o.signal),t}async _fetchTileData(s,o){const t=this.layer;if(U(t)){const l=await t.fetchTile(s[0],s[1],s[2],{noDataValue:b,signal:o.signal});return I(o)?void R.getLogger(this).warnOnce("A call to fetchTile resolved even though the request was aborted. fetchTile should not resolve if options.signal.aborted is true."):l}const e=this.getTileUrl(s),i=await o.requester.request(e,1,o),a=await this._lercDecoder.decode(i,{noDataValue:b},o.signal);if(a)return new F(a);throw new Error("LERC decoding failed")}async setModifications(s){if(this.modifications.modifications.length=0,!s||s.length===0)return;this._simplifyOperatorPromise??(this._simplifyOperatorPromise=P(()=>import("./simplifyOperator-Dsd2bGZf.js").then(t=>t.s),__vite__mapDeps([15,3,1,2,4,5,6,7,8,9,16,10])));const o=await this._simplifyOperatorPromise;for(const t of s){const e=t.geometry;if((e==null?void 0:e.type)==="polygon"){const i=o.execute(e);if((i==null?void 0:i.type)==="polygon"){const a=new B(t.type,i);this.modifications.modifications.push(a)}else R.getLogger(this).warn("Failed to simplify modification polygon")}else R.getLogger(this).warn("Invalid modification added to elevation layer: "+(e?`non polygon geometry ${e.type}`:"no geometry"))}}};x([L()],v.prototype,"layer",void 0),x([L()],v.prototype,"tileInfo",null),x([L()],v.prototype,"modifications",void 0),v=x([j("esri.views.3d.layers.ElevationLayerView3D")],v);const te=v;export{te as default};
